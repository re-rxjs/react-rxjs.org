"use strict";(self.webpackChunkreact_rxjs_org=self.webpackChunkreact_rxjs_org||[]).push([[362],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),d=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return o.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=d(n),m=a,h=u["".concat(s,".").concat(m)]||u[m]||c[m]||r;return n?o.createElement(h,i(i({ref:t},p),{},{components:n})):o.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var d=2;d<r;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7598:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return u}});var o=n(3117),a=n(102),r=(n(7294),n(3905)),i=["components"],l={title:"Todo App"},s=void 0,d={unversionedId:"tutorial/todos",id:"tutorial/todos",title:"Todo App",description:"This tutorial assumes you have gone through the Github Issues Viewer",source:"@site/docs/tutorial/todos.md",sourceDirName:"tutorial",slug:"/tutorial/todos",permalink:"/docs/tutorial/todos",draft:!1,editUrl:"https://github.com/re-rxjs/react-rxjs.org/tree/master/docs/tutorial/todos.md",tags:[],version:"current",frontMatter:{title:"Todo App"},sidebar:"someSidebar",previous:{title:"Github Issues Viewer",permalink:"/docs/tutorial/github-issues"},next:{title:"bind()",permalink:"/docs/api/core/bind"}},p={},u=[{value:"Capturing user input",id:"capturing-user-input",level:2},{value:"Creating a single stream for all the user events",id:"creating-a-single-stream-for-all-the-user-events",level:2},{value:"Creating a stream for each todo",id:"creating-a-stream-for-each-todo",level:2},{value:"Collecting the GroupedObservables",id:"collecting-the-groupedobservables",level:2},{value:"Wiring up a basic version",id:"wiring-up-a-basic-version",level:2},{value:"Cutting React out of the state management game",id:"cutting-react-out-of-the-state-management-game",level:2},{value:"Adding filters",id:"adding-filters",level:2},{value:"Adding stats",id:"adding-stats",level:2},{value:"Summary",id:"summary",level:2}],c={toc:u},m="wrapper";function h(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)(m,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{title:"Note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"This tutorial assumes you have gone through the ",(0,r.kt)("a",{parentName:"p",href:"/docs/tutorial/github-issues"},"Github Issues Viewer"),"\ntutorial, and that you are already familiar with both ",(0,r.kt)("a",{parentName:"p",href:"https://rxjs.dev"},"RxJS")," and ",(0,r.kt)("a",{parentName:"p",href:"https://reactjs.org"},"React"),".")),(0,r.kt)("p",null,"The purpose of the tutorial is to introduce the most important APIs of the\n",(0,r.kt)("inlineCode",{parentName:"p"},"@react-rxjs/utils")," package, and for that we are going to build a simple todo-list\napplication. Our app will be able to do the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add todo items"),(0,r.kt)("li",{parentName:"ul"},"Edit todo items"),(0,r.kt)("li",{parentName:"ul"},"Delete todo items"),(0,r.kt)("li",{parentName:"ul"},"Filter todo items"),(0,r.kt)("li",{parentName:"ul"},"Display useful stats")),(0,r.kt)("h2",{id:"capturing-user-input"},"Capturing user input"),(0,r.kt)("p",null,"The first thing that we should do is to capture the events triggered by the\nuser. Let's create some Signals for this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const [newTodo$, onNewTodo] = createSignal<string>();\nconst [editTodo$, onEditTodo] = createSignal<{ id: number; text: string }>();\nconst [toggleTodo$, onToggleTodo] = createSignal<number>();\nconst [deleteTodo$, onDeleteTodo] = createSignal<number>();\n")),(0,r.kt)("h2",{id:"creating-a-single-stream-for-all-the-user-events"},"Creating a single stream for all the user events"),(0,r.kt)("p",null,"It would be very convenient to have a merged stream with all those events. However,\nif we did a traditional ",(0,r.kt)("inlineCode",{parentName:"p"},"merge"),", then it would be very challenging to know the\norigin of each event."),(0,r.kt)("p",null,"That's why ",(0,r.kt)("inlineCode",{parentName:"p"},"@react-rxjs/utils")," exposes the ",(0,r.kt)("a",{parentName:"p",href:"../api/utils/mergeWithKey"},(0,r.kt)("inlineCode",{parentName:"a"},"mergeWithKey")),"\noperator. Let's use it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const todoActions$ = mergeWithKey({\n  add: newTodo$.pipe(map((text, id) => ({ id, text }))),\n  edit: editTodo$,\n  toggle: toggleTodo$.pipe(map(id => ({ id }))),\n  delete: deleteTodo$.pipe(map(id => ({ id })))\n})\n")),(0,r.kt)("p",null,"Which is basically the same as doing this (but a lot shorter, of course \ud83d\ude04):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'const todoActions$ = merge(\n  newTodo$.pipe(map((text, id) => ({\n    type: "add" as const,\n    payload: { id, text },\n  }))),\n  editTodo$.pipe(map(payload => ({\n    type: "edit" as const,\n    payload,\n  }))),\n  toggleTodo$.pipe(map(id => ({\n    type: "toggle" as const,\n    payload: { id },\n  }))),\n  deleteTodo$.pipe(map(id => ({\n    type: "delete" as const,\n    payload: { id },\n  }))),\n)\n')),(0,r.kt)("h2",{id:"creating-a-stream-for-each-todo"},"Creating a stream for each todo"),(0,r.kt)("p",null,"Now that we have put all the streams together, let's create a stream for\neach todo. And for that, we will be using another operator from ",(0,r.kt)("inlineCode",{parentName:"p"},"@react-rxjs/utils"),":\nthe ",(0,r.kt)("a",{parentName:"p",href:"../api/utils/partitionByKey"},(0,r.kt)("inlineCode",{parentName:"a"},"partitionByKey"))," operator: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'type Todo = { id: number; text: string; done: boolean };\nconst [todosMap, keys$] = partitionByKey(\n  todoActions$,\n  event => event.payload.id,\n  (event$, id) =>\n    event$.pipe(\n      takeWhile((event) => event.type !== "delete"),\n      scan(\n        (state, action) => {\n          switch (action.type) {\n            case "add":\n            case "edit":\n              return { ...state, text: action.payload.text };\n            case "toggle":\n              return { ...state, done: !state.done };\n            default:\n              return state;\n          }\n        },\n        { id, text: "", done: false } as Todo\n      )\n    )\n)\n')),(0,r.kt)("p",null,"Now we have a function, ",(0,r.kt)("inlineCode",{parentName:"p"},"todosMap"),", that returns an Observable of events\nassociated with a given todo. ",(0,r.kt)("inlineCode",{parentName:"p"},"partitionByKey")," transforms the source observable in a way\nsimilar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"groupBy")," operator that's exposed from RxJS. However, there are\nsome important differences:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"partitionByKey")," gives you a function that returns an Observable, rather\nthan an Observable that emits Observables. It also provides an Observable\nthat emits the list of keys, whenever that list changes (",(0,r.kt)("inlineCode",{parentName:"li"},"keys$")," in the code\nabove)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"partitionByKey"),' has an optional third parameter which allows you to create\na complex inner stream that will become the "grouped" stream that is\nreturned.'),(0,r.kt)("li",{parentName:"ul"},"This returned stream is enhanced with a\n",(0,r.kt)("a",{parentName:"li",href:"../api/core/shareLatest"},(0,r.kt)("inlineCode",{parentName:"a"},"shareLatest"))," and ",(0,r.kt)("inlineCode",{parentName:"li"},"partitionByKey")," internally\nsubscribes to it as soon as it is created to ensure that the consumer always\nhas the latest value.")),(0,r.kt)("h2",{id:"collecting-the-groupedobservables"},"Collecting the GroupedObservables"),(0,r.kt)("p",null,"We now have a way of getting streams for each todo, and we have a stream\n(",(0,r.kt)("inlineCode",{parentName:"p"},"keys$"),") that represents the list of todos by their ids and emits whenever\none is added or deleted. We should also like a stream that emits whenever\nthe state of any todo changes, and gives us access to all of them.\n",(0,r.kt)("a",{parentName:"p",href:"../api/utils/combineKeys"},(0,r.kt)("inlineCode",{parentName:"a"},"combineKeys()"))," suits this purpose. Let's try it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const todosMap$: Observable<Map<number, Todo>> = combineKeys(keys$, todosMap);\n")),(0,r.kt)("p",null,"And with this we are ready to start wiring things up."),(0,r.kt)("h2",{id:"wiring-up-a-basic-version"},"Wiring up a basic version"),(0,r.kt)("p",null,"Let's start with the top-level component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const [useTodos] = bind(todosMap$.pipe(map(todosMap => [...todosMap.values()])))\n\nfunction TodoList() {\n  const todoList = useTodos()\n\n  return (\n    <>\n      {/* <TodoListStats /> */}\n      {/* <TodoListFilters /> */}\n      <TodoItemCreator />\n\n      {todoList.map((todoItem) => (\n        <TodoItem key={todoItem.id} item={todoItem} />\n      ))}\n    </>\n  );\n}\n")),(0,r.kt)("p",null,"Next, let's implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"TodoItemCreator"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function TodoItemCreator() {\n  const [inputValue, setInputValue] = useState('');\n\n  const addItem = () => {\n    onNewTodo(inputValue);\n    setInputValue('');\n  };\n\n  const onChange = ({target: {value}}) => {\n    setInputValue(value);\n  };\n\n  return (\n    <div>\n      <input type=\"text\" value={inputValue} onChange={onChange} />\n      <button onClick={addItem}>Add</button>\n    </div>\n  );\n}\n")),(0,r.kt)("p",null,"And finally, the ",(0,r.kt)("inlineCode",{parentName:"p"},"TodoItem")," component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'function TodoItem({item}) {\n  const editItemText = ({target: {value}}) => {\n    onEditTodo(item.id, value)\n  }\n\n  const toggleItemCompletion = () => {\n    onToggleTodo(item.id)\n  }\n\n  const deleteItem = () => {\n    onDeleteTodo(item.id)\n  }\n\n  return (\n    <div>\n      <input type="text" value={item.text} onChange={editItemText} />\n      <input\n        type="checkbox"\n        checked={item.done}\n        onChange={toggleItemCompletion}\n      />\n      <button onClick={deleteItem}>X</button>\n    </div>\n  )\n}\n')),(0,r.kt)("p",null,"That's it! We have a basic version working."),(0,r.kt)("h2",{id:"cutting-react-out-of-the-state-management-game"},"Cutting React out of the state management game"),(0,r.kt)("p",null,"What we've done so far is pretty neat, but there are a lot of unnecessary\nrenders going on in our application. Editing any of the todos, for example,\ncauses the whole list to re-render. To those with experience in React\ndevelopment, this hardly seems noteworthy\u2014our state is our list of todos, it\nlives in our TodoList component, so of course it re-renders when that state\nchanges. With React-RxJS, we can do better. Before we proceed with the\nremaining features, let's relieve React of its state management\nresponsibilities altogether."),(0,r.kt)("p",null,"Take a look at the stream we've bound to the TodoList component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const [useTodos] = bind(todosMap$.pipe(map(todosMap => [...todosMap.values()])));\n")),(0,r.kt)("p",null,"This is just an ",(0,r.kt)("inlineCode",{parentName:"p"},"Observable<Todo[]>"),", and it will emit every time any todo\ngets updated\u2014triggering a TodoList render. In fact TodoList only needs to know\nwhich todos to display; rendering them according to their properties can be\nleft up to the child component, TodoItem. Therefore let's bind a list of\n",(0,r.kt)("em",{parentName:"p"},"which")," todos exist. Luckily we already have a stream for that, returned above\nby ",(0,r.kt)("inlineCode",{parentName:"p"},"partitionByKey"),". So:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const [useTodoIds] = bind(keys$);\n")),(0,r.kt)("p",null,"Simple! Now we edit our TodoList component to pass just the todo id:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"}," function TodoList() {\n-  const todoList = useTodos();\n+  const todoIds = useTodos();\n\n   return (\n     <>\n       <TodoListStats />\n       <TodoListFilters />\n       <TodoItemCreator />\n \n-      {todoList.map((todoItem) => (\n-        <TodoItem key={todoItem.id} item={todoItem} />\n-      ))}\n+      {todoIds.map((id) => (\n+      <TodoItem key={id} id={id} />\n+      ))}\n     </>\n   );\n }\n")),(0,r.kt)("p",null,"and teach TodoItem to get its state from the stream corresponding to that id,\nrather than from its parent component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const TodoItem: React.FC<{ id: number }> = ({ id }) => {\n  const item = useTodo(id);\n\n  return( ... )\n}\n")),(0,r.kt)("h2",{id:"adding-filters"},"Adding filters"),(0,r.kt)("p",null,"As we already know, we will need to capture the filter selected by the user:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'export enum FilterType {\n  All = "all",\n  Done = "done",\n  Pending = "pending"\n}\nconst [selectedFilter$, onSelectFilter] = createSignal<FilterType>()\n')),(0,r.kt)("p",null,"Next, let's create a hook and a stream for the current filter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const [useCurrentFilter, currentFilter$] = bind(\n  selectedFilter$.pipe(startWith(FilterType.All))\n)\n")),(0,r.kt)("p",null,"Also, let's tell our TodoItems not to render if they've been filtered out:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"}," const TodoItem: React.FC<{ id: number }> = ({ id }) => {\n   const item = useTodo(id);\n+  const currentFilter = useCurrentFilter();\n  \n   return ( ... );\n }\n")),(0,r.kt)("p",null,"Time to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"TodoListFilters")," component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function TodoListFilters() {\n  const filter = useCurrentFilter()\n\n  const updateFilter = ({target: {value}}) => {\n    onSelectFilter(value)\n  };\n\n  return (\n    <>\n      Filter:\n      <select value={filter} onChange={updateFilter}>\n        <option value={FilterType.All}>All</option>\n        <option value={FilterType.Done}>Completed</option>\n        <option value={FilterType.Pending}>Uncompleted</option>\n      </select>\n    </>\n  );\n}\n")),(0,r.kt)("h2",{id:"adding-stats"},"Adding stats"),(0,r.kt)("p",null,"We will be showing the following stats:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Total number of todo items"),(0,r.kt)("li",{parentName:"ul"},"Total number of completed items"),(0,r.kt)("li",{parentName:"ul"},"Total number of uncompleted items"),(0,r.kt)("li",{parentName:"ul"},"Percentage of items completed")),(0,r.kt)("p",null,"Let's create a ",(0,r.kt)("inlineCode",{parentName:"p"},"useTodosStats")," for it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const [useTodosStats] = bind(\n  todosList$.pipe(map(todosList => {\n    const nTotal = todosList.length\n    const nCompleted = todosList.filter((item) => item.done).length\n    const nUncompleted = nTotal - nCompleted\n    const percentCompleted = \n      nTotal === 0 ? 0 : Math.round((nCompleted / nTotal) * 100)\n\n    return {\n      nTotal,\n      nCompleted,\n      nUncompleted,\n      percentCompleted,\n    }\n  }))\n)\n")),(0,r.kt)("p",null,"And now let's use this hook in the ",(0,r.kt)("inlineCode",{parentName:"p"},"TodoListStats")," component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function TodoListStats() {\n  const { nTotal, nCompleted, nUncompleted, percentCompleted } = useTodosStats()\n\n  return (\n    <ul>\n      <li>Total items: {nTotal}</li>\n      <li>Items completed: {nCompleted}</li>\n      <li>Items not completed: {nUncompleted}</li>\n      <li>Percent completed: {percentCompleted}</li>\n    </ul>\n  );\n}\n")),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"The result of this tutorial can be seen in this CodeSandbox:"),(0,r.kt)("iframe",{src:"https://codesandbox.io/embed/react-rxjs-basic-todos-nd8rn?fontsize=14&hidenavigation=1&theme=dark&view=editor",style:{width:"100%",height:"500px",border:0,borderRadius:"4px",overflow:"hidden"},title:"react-rxjs-github-issues-example",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}))}h.isMDXComponent=!0}}]);