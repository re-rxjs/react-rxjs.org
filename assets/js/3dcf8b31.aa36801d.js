"use strict";(self.webpackChunkreact_rxjs_org=self.webpackChunkreact_rxjs_org||[]).push([[386],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var s=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,s,a=function(e,t){if(null==e)return{};var n,s,a={},r=Object.keys(e);for(s=0;s<r.length;s++)n=r[s],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(s=0;s<r.length;s++)n=r[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=s.createContext({}),l=function(e){var t=s.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=l(e.components);return s.createElement(p.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},h=s.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,p=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=l(n),h=a,d=c["".concat(p,".").concat(h)]||c[h]||m[h]||r;return n?s.createElement(d,o(o({ref:t},u),{},{components:n})):s.createElement(d,o({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=h;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[c]="string"==typeof e?e:a,o[1]=i;for(var l=2;l<r;l++)o[l]=n[l];return s.createElement.apply(null,o)}return s.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8276:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return g},frontMatter:function(){return p},metadata:function(){return u},toc:function(){return m}});var s=n(3117),a=n(102),r=(n(7294),n(3905)),o=n(4996),i=["components"],p={title:"Github Issues Viewer"},l=void 0,u={unversionedId:"tutorial/github-issues",id:"tutorial/github-issues",title:"Github Issues Viewer",description:"This tutorial assumes you are already familiar with both RxJS",source:"@site/docs/tutorial/github-issues.md",sourceDirName:"tutorial",slug:"/tutorial/github-issues",permalink:"/docs/tutorial/github-issues",draft:!1,editUrl:"https://github.com/re-rxjs/react-rxjs.org/tree/master/docs/tutorial/github-issues.md",tags:[],version:"current",frontMatter:{title:"Github Issues Viewer"},sidebar:"someSidebar",previous:{title:"Getting Started",permalink:"/docs/getting-started"},next:{title:"Todo App",permalink:"/docs/tutorial/todos"}},c={},m=[{value:"Reviewing the Starting Example Application",id:"reviewing-the-starting-example-application",level:2},{value:"React Codebase Source Overview",id:"react-codebase-source-overview",level:3},{value:"Changing the dependencies",id:"changing-the-dependencies",level:3},{value:"Refactor API: Axios -&gt; RxJS",id:"refactor-api-axios---rxjs",level:3},{value:"Identifying the state of the App",id:"identifying-the-state-of-the-app",level:2},{value:"Defining the state of the App",id:"defining-the-state-of-the-app",level:2},{value:"Wiring things up!",id:"wiring-things-up",level:2},{value:"Main App Component",id:"main-app-component",level:3},{value:"RepoSearchForm",id:"reposearchform",level:3},{value:"IssuesListPage",id:"issueslistpage",level:3},{value:"IssuesPageHeader",id:"issuespageheader",level:4},{value:"IssuePagination",id:"issuepagination",level:4},{value:"IssuesList",id:"issueslist",level:4},{value:"IssueDetailsPage",id:"issuedetailspage",level:3},{value:"IssueComments",id:"issuecomments",level:4},{value:"Summary",id:"summary",level:2},{value:"Bonus: Code splitting",id:"bonus-code-splitting",level:2}],h={toc:m},d="wrapper";function g(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)(d,(0,s.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{title:"Note",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"This tutorial assumes you are already familiar with both ",(0,r.kt)("a",{parentName:"p",href:"https://rxjs.dev"},"RxJS"),"\nand ",(0,r.kt)("a",{parentName:"p",href:"https://reactjs.org"},"React"),".")),(0,r.kt)("p",null,"For this tutorial we will be borrowing the Github issues example that is taught\nin the ",(0,r.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/tutorials/advanced-tutorial"},"Advanced Tutorial"),"\nof the ",(0,r.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org"},"Redux Toolkit"),"."),(0,r.kt)("p",null,"It's a great example because it starts with a plain React application and it then\nshows how to migrate that application to Redux using the Redux Toolkit (RTK). One of the many good\nthings about the tutorial, is that it illustrates the mental models required to manage\nstate efficiently with RTK. In this tutorial we will try to follow the same approach."),(0,r.kt)("h2",{id:"reviewing-the-starting-example-application"},"Reviewing the Starting Example Application"),(0,r.kt)("p",null,"The example application for this tutorial is a Github Issues viewer app. It allows\nthe user to enter the names of a Github org and repository, fetch the current list\nof open issues, page through the issues list, and view the contents and comments\nof a specific issue."),(0,r.kt)("p",null,"The starting commit for this application is a plain React implementation that uses\nfunction components with hooks for state and side effects like data fetching. The\ncode is already written in TypeScript, and the styling is done via CSS Modules."),(0,r.kt)("p",null,"Let's start by viewing the original plain React app in action:"),(0,r.kt)("iframe",{src:"https://codesandbox.io/embed/github/re-rxjs/react-rxjs-github-issues-example/tree/plain-react?fontsize=14&hidenavigation=1&theme=dark&view=preview",style:{width:"100%",height:"500px",border:0,borderRadius:"4px",overflow:"hidden"},title:"react-rxjs-github-issues-example-plain-react",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),(0,r.kt)("p",null,"It's worth noting that there are a couple of tiny bugs (or annoyances) with this\nReact implementation:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'Changing the "Issues Page" number and jumping to that page will highlight the\npagination number on the footer. However, changing the pagination number through\nthe footer does not update the pagination number at the top.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When the user loads a different repo, the issues page doesn't go back to the first page,\nwhich is problematic: If the user was looking at page 5 of the initial repo\nand then tries to go to a different repo which doesn't have as many pages,\nthe results don't load properly. We think that it would be desirable to go back\nto the first page whenever the user loads a different repo."))),(0,r.kt)("p",null,"We will be addressing these issues as we migrate the initial code to React-RxJS."),(0,r.kt)("h3",{id:"react-codebase-source-overview"},"React Codebase Source Overview"),(0,r.kt)("p",null,'The codebase is already laid out in a "feature folder" structure, The main pieces are:'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/api"),": fetching functions and TS types for the Github Issues API"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/app"),": main ",(0,r.kt)("inlineCode",{parentName:"li"},"<App>")," component"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/components"),": components that are reused in multiple places"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/features"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/issueDetails:")," components for the Issue Details page"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/issuesList"),": components for the Issues List display"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/repoSearch"),": components for the Repo Search form"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/utils"),": various string utility functions")),(0,r.kt)("h3",{id:"changing-the-dependencies"},"Changing the dependencies"),(0,r.kt)("p",null,"For this tutorial we will need the following dependencies:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rxjs"),": since these are bindings for RxJS \ud83d\ude04"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@react-rxjs/core"),": the core package of React-RxJS"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"react-error-boundary"),": React-RxJS integrates very nicely with React Error\nBoundaries. ",(0,r.kt)("inlineCode",{parentName:"li"},"react-error-boundary")," is a tiny library that provides a nice\nabstraction to build them, by declaring a fallback component and recovery strategy,\nin a similar way to Suspense Boundaries.")),(0,r.kt)("p",null,"Also, we are not going to need Axios, because we will be using ",(0,r.kt)("inlineCode",{parentName:"p"},"rxjs/ajax")," instead."),(0,r.kt)("h3",{id:"refactor-api-axios---rxjs"},"Refactor API: Axios -> RxJS"),(0,r.kt)("p",null,"The original API uses Axios, which is a great tool for handling requests. We could\nkeep the API as it is, because RxJS can easily treat Promises as Observables.\nHowever, since we are going to be using RxJS, it makes sense to use RxJS instead\nof Axios. It's a pretty straightforward change:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"-import axios from 'axios'\n+import { ajax } from 'rxjs/ajax'\n import parseLink, { Links } from 'parse-link-header'\n+import { map } from 'rxjs/operators'\n+import { Observable } from 'rxjs'\n\n export interface Label {\n   id: number\n@@ -64,47 +66,40 @@ const getPageCount = (pageLinks: Links) => {\n   }\n }\n\n-export async function getIssues(\n+export function getIssues(\n   org: string,\n   repo: string,\n   page = 1\n-): Promise<IssuesResult> {\n+): Observable<IssuesResult> {\n   const url = `https://api.github.com/repos/${org}/${repo}/issues?per_page=25&page=${page}`\n-\n-  try {\n-    const issuesResponse = await axios.get<Issue[]>(url)\n-    let pageCount = 0\n-    const pageLinks = parseLink(issuesResponse.headers.link)\n-\n-    if (pageLinks !== null) {\n-      pageCount = getPageCount(pageLinks)\n-    }\n-\n-    return {\n-      pageLinks,\n-      pageCount,\n-      issues: issuesResponse.data,\n-    }\n-  } catch (err) {\n-    throw err\n-  }\n+  return ajax.get(url).pipe(\n+    map((r) => {\n+      let pageCount = 0\n+      const pageLinks = parseLink(r.xhr.getResponseHeader('link') as string)\n+\n+      if (pageLinks !== null) {\n+        pageCount = getPageCount(pageLinks)\n+      }\n+\n+      return {\n+        pageLinks,\n+        pageCount,\n+        issues: r.response as Issue[],\n+      }\n+    })\n+  )\n }\n\n-export async function getRepoDetails(org: string, repo: string) {\n+export function getRepoOpenIssuesCount(org: string, repo: string) {\n   const url = `https://api.github.com/repos/${org}/${repo}`\n-\n-  const { data } = await axios.get<RepoDetails>(url)\n-  return data\n+  return ajax\n+    .getJSON<RepoDetails>(url)\n+    .pipe(map((repoDetails) => repoDetails.open_issues_count))\n }\n\n-export async function getIssue(org: string, repo: string, number: number) {\n+export function getIssue(org: string, repo: string, number: number) {\n   const url = `https://api.github.com/repos/${org}/${repo}/issues/${number}`\n-\n-  const { data } = await axios.get<Issue>(url)\n-  return data\n+  return ajax.getJSON<Issue>(url)\n }\n\n-export async function getComments(url: string) {\n-  const { data } = await axios.get<Comment[]>(url)\n-  return data\n+export function getComments(url: string) {\n+  return ajax.getJSON<Comment[]>(url)\n }\n")),(0,r.kt)("h2",{id:"identifying-the-state-of-the-app"},"Identifying the state of the App"),(0,r.kt)("p",null,"Now that we have everything ready, let's think for a moment about the state of\nthis app. Luckily for us, there is not a lot of it. So, let's represent the different\nstate entities and their relations on a diagram:"),(0,r.kt)("img",{src:(0,o.Z)("img/github-issues-dependencies.png"),alt:"A diagram that represents the relations of the entities. At the top we have the user inputs,\nfollowed by those states that depend on them directly. One level below we have those states\nthat depend on other states."}),(0,r.kt)("p",null,"At the very top we have the different events that can happen. The 3 different user interactions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Changing the repo"),(0,r.kt)("li",{parentName:"ul"},"Changing the page"),(0,r.kt)("li",{parentName:"ul"},"Selecting / unselecting an issue")),(0,r.kt)("p",null,"These are the events that will propagate changes to our state entities."),(0,r.kt)("p",null,"Then we have the following state entities:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},'"Current repo & page"'),": Since the page and the repo are very tightly coupled, it makes\nsense to have an entity that represents the current state of the both of them. This entity\ndepends on 2 different user interactions: changing the repo and changing the page.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"From this entity we can easily derive the ",(0,r.kt)("strong",{parentName:"p"},'"list of issues"')," and the ",(0,r.kt)("strong",{parentName:"p"},'"current page"'),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We also have the ",(0,r.kt)("strong",{parentName:"p"},'"# of open issues"'),' which depends on the "changing repo" event.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Then there is the ",(0,r.kt)("strong",{parentName:"p"},'"issue details"')," which will change whenever the user selects/unselects an issue.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"And finally we have the ",(0,r.kt)("strong",{parentName:"p"},'"issue comments"'),' which depend on the "issue details".'))),(0,r.kt)("p",null,"That's it. That's all the app-level state. It's worth pointing out that the UI\ndoesn't allow the user to change the repo or the page while there is a selected issue."),(0,r.kt)("h2",{id:"defining-the-state-of-the-app"},"Defining the state of the App"),(0,r.kt)("p",null,"Now that we have identified the state, let's represent it using RxJS streams, and\nlet's create the necessary React hooks."),(0,r.kt)("p",null,"One nice thing about Reactive Programming is that it's possible to declare state\nin a way that reads from top to bottom. That's because each state entity is only\ncoupled to the entities that it depends on."),(0,r.kt)("p",null,"In order to illustrate that, we will be putting all the state of this app in the\nsame file. Normally, it would be better to break this file down into smaller\npieces and to co-locate each piece closer to where it is being used."),(0,r.kt)("p",null,"Let's first define and export the default states of the app:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'export const INITIAL_ORG = "rails"\nexport const INITIAL_REPO = "rails"\n')),(0,r.kt)("p",null,"Next, let's create the entry points for the user interactions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const repoSubject$ = new Subject<{ org: string; repo: string }>()\nexport const onLoadRepo = (org: string, repo: string) => {\n  repoSubject$.next({ org, repo })\n}\n\nconst pageSelected$ = new Subject<number>()\nexport const onPageChange = (nextPage: number) => {\n  pageSelected$.next(nextPage)\n}\n\nconst issueSelected$ = new Subject<number | null>()\nexport const onIssueSelected = (id: number) => {\n  issueSelected$.next(id)\n}\nexport const onIssueUnselecteed = () => {\n  issueSelected$.next(null)\n}\n")),(0,r.kt)("p",null,'Now that we already have the top-level streams, let\'s create a stream that represents\nthe "current repo and page" entity. We want to reset the page to 1 when the selected repo changes,\nso we can represent this behavior with ',(0,r.kt)("inlineCode",{parentName:"p"},"merge"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export const [useCurrentRepo, currentRepo$] = bind(\n  repoSubject$.pipe(\n    startWith({\n      org: INITIAL_ORG,\n      repo: INITIAL_REPO,\n    }),\n  ),\n)\n\nconst currentRepoAndPage$ = merge(\n  // When repo changes, update repo and reset page to 1\n  currentRepo$.pipe(\n    map((currentRepo) => ({\n      ...currentRepo,\n      page: 1,\n    })),\n  ),\n  // When page changes\n  pageSelected$.pipe(\n    filter((page) => page > 0),\n    // keep same repo, update page\n    withLatestFrom(currentRepo$),\n    map(([page, repo]) => ({ ...repo, page })),\n  ),\n).pipe(shareLatest())\n")),(0,r.kt)("p",null,"From this stream we can extract the current page:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export const [useCurrentPage] = bind(\n  currentRepoAndPage$.pipe(map(({ page }) => page)),\n)\n")),(0,r.kt)("p",null,"And following our model, the list of issues also depends on this stream, but the\nlist of issues needs to be loaded from the API."),(0,r.kt)("p",null,'In this example we also want to use React Suspense: When the user changes the repo\nor page, we want to show a suspended state while the new issue list is loading\n(i.e. "Loading issues..."). The way we can do this, is by emitting the\n',(0,r.kt)("a",{parentName:"p",href:"../api/core/suspense"},(0,r.kt)("inlineCode",{parentName:"a"},"SUSPENSE"))," symbol, that means that there's data being loaded in this stream.\nThis can be expressed reactively as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export const [useIssues, issues$] = bind(\n  currentRepoAndPage$.pipe(\n    switchMap(({ page, repo, org }) =>\n      getIssues(org, repo, page).pipe(startWith(SUSPENSE)),\n    ),\n  ),\n)\n")),(0,r.kt)("p",null,"This way, every time the current repo or page changes, the ",(0,r.kt)("inlineCode",{parentName:"p"},"useIssues")," hook\nwill send another query to the API to keep everything up to date, suspending the\ncomponent(s) that depend on it while it's fetching the new values."),(0,r.kt)("p",null,"We can use the same pattern to retrieve the number of open issues:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export const [useOpenIssuesLen, openIssuesLen$] = bind(\n  currentRepo$.pipe(\n    switchMap(({ org, repo }) =>\n      getRepoOpenIssuesCount(org, repo).pipe(startWith(SUSPENSE)),\n    ),\n  ),\n)\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Now, since ",(0,r.kt)("inlineCode",{parentName:"p"},"issues$")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"openIssuesLen$")," are observables that trigger side-effects,\nit's important that their initial subscriptions happen before react renders the\ncomponents that depend on them. That's why we are going to define a top-level\nsubscription that ensures that."),(0,r.kt)("p",{parentName:"admonition"},"We need to also make sure that an error won't close this top-level subscription:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"merge(issues$, openIssuesLen$)\n  .pipe(retryWhen(() => currentRepoAndPage$.pipe(skip(1))))\n  .subscribe()\n")),(0,r.kt)("p",null,"And lastly we need to declare the state when an issue is selected: Following\nsimilar logic, we need to load the issue details when an issue is selected,\nas well as its comments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export const [useSelectedIssueId, selectedIssueId$] = bind(\n  issueSelected$.pipe(startWith(null)),\n)\n\nexport const [useIssue, issue$] = bind(\n  selectedIssueId$.pipe(\n    filter((id): id is number => id !== null),\n    withLatestFrom(currentRepo$),\n    switchMap(([id, { org, repo }]) =>\n      getIssue(org, repo, id).pipe(startWith(SUSPENSE)),\n    ),\n  ),\n)\n\nexport const [useIssueComments, issueComments$] = bind(\n  issue$.pipe(\n    filter((issue): issue is Issue => issue !== SUSPENSE),\n    switchMap(issue => getComments(issue.comments_url).pipe(startWith(SUSPENSE)),\n  ),\n)\n")),(0,r.kt)("p",null,"As this pattern of ",(0,r.kt)("inlineCode",{parentName:"p"},"switchMap")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"startWith(SUSPENSE)")," is something that's\noften used, react-rxjs exports ",(0,r.kt)("a",{parentName:"p",href:"../api/utils/switchMapSuspended"},(0,r.kt)("inlineCode",{parentName:"a"},"switchMapSuspended")),"\nin ",(0,r.kt)("inlineCode",{parentName:"p"},"@react-rxjs/utils")," that makes it sightly less verbose."),(0,r.kt)("p",null,"Here we also need to create a subscription to ",(0,r.kt)("inlineCode",{parentName:"p"},"issueComments$")," in order to ensure\nthat the first subscription happens before react renders the components that\ndepend on it. Notice that by just subscribing to ",(0,r.kt)("inlineCode",{parentName:"p"},"issueComment$"),", all the streams\nthat depend on it will also get a subscription:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"selectedIssueId$\n  .pipe(switchMapTo(issueComments$.pipe(catchError(() => EMPTY))))\n  .subscribe()\n")),(0,r.kt)("h2",{id:"wiring-things-up"},"Wiring things up!"),(0,r.kt)("p",null,"Now that we have all the application state declared, we can wire it up\nwith the components."),(0,r.kt)("h3",{id:"main-app-component"},"Main App Component"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/re-rxjs/react-rxjs-github-issues-example/commit/d3932f4cf64943e831fc710638669ce3fca75d84#diff-34456421648850188ad56fcd6df47b2b"},"diff of this component is so brutal"),"\nthat it's best to show how the code looks with react-rxjs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'import React, { Suspense, lazy } from "react"\nimport "./App.css"\nimport { RepoSearchForm } from "features/repoSearch/RepoSearchForm"\nimport { IssuesListPage } from "features/issuesList/IssuesListPage"\nimport { IssuesDetailsPage } from "features/issueDetails/IssueDetailsPage"\nimport { useSelectedIssueId } from "state"\n\nconst List: React.FC = () => {\n  const id = useSelectedIssueId()\n  return id !== null ? null : (\n    <>\n      <RepoSearchForm />\n      <IssuesListPage />\n    </>\n  )\n}\n\nconst App: React.FC = () => {\n  return (\n    <div className="App">\n      <List />\n      <Suspense fallback={null}>\n        <IssueDetailsPage />\n      </Suspense>\n    </div>\n  )\n}\n\nexport default App\n')),(0,r.kt)("p",null,"With Suspense, we don't need to manage the loading states by ourselves - React\nwill. This, coupled with the fact that the state can be lifted out, allows us to simplify\nthe original app to a couple of simple components."),(0,r.kt)("h3",{id:"reposearchform"},"RepoSearchForm"),(0,r.kt)("p",null,"For the \"search repository\" form, by having the state in a separate file, we can\njust import those bits that we need directly, and this way the parent doesn't\nneed to get coupled to values that it doesn't need:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"-import React, { useState, ChangeEvent } from 'react'\n+import React, { useState, ChangeEvent, useEffect } from 'react'\n\n import './pure-forms.css'\n import './pure-buttons.css'\n-\n-interface Props {\n-  org: string\n-  repo: string\n-  setOrgAndRepo: (org: string, repo: string) => void\n-  setJumpToPage: (page: number) => void\n-}\n+import {\n+  useCurrentPage,\n+  onLoadRepo,\n+  onPageChange,\n+  INITIAL_REPO,\n+  INITIAL_ORG,\n+} from 'state'\n\n type InputEvent = ChangeEvent<HTMLInputElement>\n type ChangeHandler = (e: InputEvent) => void\n\n-export const RepoSearchForm = ({\n-  org,\n-  repo,\n-  setOrgAndRepo,\n-  setJumpToPage,\n-}: Props) => {\n-  const [currentOrg, setCurrentOrg] = useState(org)\n-  const [currentRepo, setCurrentRepo] = useState(repo)\n-  const [currentPageText, setCurrentPageText] = useState('1')\n+export const RepoSearchForm: React.FC = () => {\n+  const [currentOrg, setCurrentOrg] = useState(INITIAL_ORG)\n+  const [currentRepo, setCurrentRepo] = useState(INITIAL_REPO)\n+  const page = useCurrentPage()\n+  const [currentPageText, setCurrentPageText] = useState(page.toString())\n+  useEffect(() => setCurrentPageText(page.toString()), [page])\n\n   const onOrgChanged: ChangeHandler = (e) => {\n     setCurrentOrg(e.target.value)\n@@ -36,14 +33,14 @@ export const RepoSearchForm = ({\n   }\n\n   const onLoadRepoClicked = () => {\n-    setOrgAndRepo(currentOrg, currentRepo)\n+    onLoadRepo(currentOrg, currentRepo)\n   }\n\n   const onJumpToPageClicked = () => {\n     const newPage = parseInt(currentPageText)\n\n     if (newPage >= 1) {\n-      setJumpToPage(newPage)\n+      onPageChange(newPage)\n     }\n   }\n")),(0,r.kt)("h3",{id:"issueslistpage"},"IssuesListPage"),(0,r.kt)("p",null,"The page for the list of issues is also ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/re-rxjs/react-rxjs-github-issues-example/commit/d3932f4cf64943e831fc710638669ce3fca75d84#diff-86b21025fd105e75d28d28541f8288b5"},"greatly simplified"),",\nbecause all the state management on this part is already done, and it turns out\nthat this component is not the consumer of any of the state it managed - The\nconsumers are their children, which will access whatever they need themselves."),(0,r.kt)("p",null,"This component still has a responsibility though: to catch any error that would\nhappen on fetch, and show a fallback UI. React-RxJS lets us use ErrorBoundaries,\nnot only for the regular errors that happen within React's Components, but also\nfor those errors that are generated in a stream."),(0,r.kt)("p",null,"What will happen is that, if a component uses a stream that emits an error, it\nwill propagate that error to the nearest error boundary. If that happens, the\nError Boundary will show the fallback UI, and we can decide how to recover. In\nour case, we want to show the components when the user selects another\nrepository or another page, so we can set this up easily by using a ",(0,r.kt)("inlineCode",{parentName:"p"},"useEffect"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'import React, { useEffect } from "react"\nimport { ErrorBoundary, FallbackProps } from "react-error-boundary"\nimport { IssuesPageHeader } from "./IssuesPageHeader"\nimport { IssuesList } from "./IssuesList"\nimport { IssuePagination } from "./IssuePagination"\nimport { currentRepoAndPage$ } from "state"\nimport { skip, take } from "rxjs/operators"\n\nconst OnError: React.FC<FallbackProps> = ({ error, resetErrorBoundary }) => {\n  useEffect(() => {\n    const subscription = currentRepoAndPage$\n      .pipe(skip(1), take(1))\n      .subscribe(resetErrorBoundary)\n    return () => subscription.unsubscribe()\n  }, [resetErrorBoundary])\n  return (\n    <div>\n      <h1>Something went wrong...</h1>\n      <div>{error && error.message}</div>\n    </div>\n  )\n}\n\nexport const IssuesListPage = () => {\n  return (\n    <ErrorBoundary FallbackComponent={OnError}>\n      <div id="issue-list-page">\n        <IssuesPageHeader />\n        <IssuesList />\n        <IssuePagination />\n      </div>\n    </ErrorBoundary>\n  )\n}\n')),(0,r.kt)("h4",{id:"issuespageheader"},"IssuesPageHeader"),(0,r.kt)("p",null,"For the header, we can get rid of its props (as we have already declared its state),\nand we will also take the chance to represent the loading state by\nusing React's Suspense:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"-import React from 'react'\n+import React, { Suspense } from 'react'\n+import { useOpenIssuesLen, useCurrentRepo } from 'state'\n\n-interface OrgProps {\n-  org: string\n-  repo: string\n-}\n-\n-type HeaderProps = {\n-  openIssuesCount: number\n-} & OrgProps\n-\n-function OrgRepo({ org, repo }: OrgProps) {\n+function OrgRepo() {\n+  const { org, repo } = useCurrentRepo()\n   return (\n     <span>\n       <a href={`https://github.com/${org}`} className=\"header__org\">\n@@ -23,24 +16,23 @@ function OrgRepo({ org, repo }: OrgProps) {\n   )\n }\n\n-export function IssuesPageHeader({\n-  openIssuesCount = -1,\n-  org,\n-  repo,\n-}: HeaderProps) {\n-  if (openIssuesCount === -1) {\n-    return (\n-      <h1>\n-        Open issues for <OrgRepo org={org} repo={repo} />\n-      </h1>\n-    )\n-  } else {\n-    const pluralizedIssue = openIssuesCount === 1 ? 'issue' : 'issues'\n-    return (\n-      <h1>\n-        <span className=\"header__openIssues\">{openIssuesCount}</span> open{' '}\n-        {pluralizedIssue} for <OrgRepo org={org} repo={repo} />\n-      </h1>\n-    )\n-  }\n+function OpenIssues() {\n+  const openIssuesCount = useOpenIssuesLen()\n+  return (\n+    <>\n+      <span className=\"header__openIssues\">{openIssuesCount}</span> open{' '}\n+      {openIssuesCount === 1 ? 'issue' : 'issues'} for {}\n+    </>\n+  )\n+}\n+\n+export function IssuesPageHeader() {\n+  return (\n+    <h1>\n+      <Suspense fallback={'Open issues for '}>\n+        <OpenIssues />\n+      </Suspense>\n+      <OrgRepo />\n+    </h1>\n+  )\n }\n")),(0,r.kt)("h4",{id:"issuepagination"},"IssuePagination"),(0,r.kt)("p",null,"The same logic applies for the pagination component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"-import React from 'react'\n+import React, { Suspense } from 'react'\n import classnames from 'classnames'\n-import Paginate, { ReactPaginateProps } from 'react-paginate'\n+import Paginate from 'react-paginate'\n\n import styles from './IssuePagination.module.css'\n import './IssuePagination.css'\n+import { useCurrentPage, useIssues, onPageChange } from 'state'\n\n-export type OnPageChangeCallback = ReactPaginateProps['onPageChange']\n-interface Props {\n-  currentPage: number\n-  pageCount: number\n-  onPageChange?: OnPageChangeCallback\n-}\n-\n-export const IssuePagination = ({\n-  currentPage,\n-  pageCount,\n-  onPageChange,\n-}: Props) => {\n+const IssuePaginationLoaded = () => {\n+  const currentPage = useCurrentPage() - 1\n+  const { pageCount } = useIssues()\n\n-  return (\n+  return pageCount === 0 ? null : (\n     <div className={classnames('issuesPagination', styles.pagination)}>\n       <Paginate\n         forcePage={currentPage}\n         pageCount={pageCount}\n         marginPagesDisplayed={2}\n         pageRangeDisplayed={5}\n-        onPageChange={onPageChange}\n+        onPageChange={({ selected }) => onPageChange(selected + 1)}\n         nextLabel=\"&rarr;\"\n         previousLabel=\"&larr;\"\n       />\n     </div>\n   )\n }\n+\n+export const IssuePagination = () => (\n+  <Suspense fallback={null}>\n+    <IssuePaginationLoaded />\n+  </Suspense>\n+)\n")),(0,r.kt)("h4",{id:"issueslist"},"IssuesList"),(0,r.kt)("p",null,"And the list:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"-import React from 'react'\n+import React, { Suspense } from 'react'\n\n-import { Issue } from 'api/githubAPI'\n import { IssueListItem } from './IssueListItem'\n\n import styles from './IssuesList.module.css'\n+import { useIssues } from 'state'\n\n-interface Props {\n-  issues: Issue[]\n-  showIssueComments: (issueId: number) => void\n-}\n-\n-export const IssuesList = ({ issues, showIssueComments }: Props) => {\n+const IssuesListLoaded = () => {\n+  const { issues } = useIssues()\n   const renderedIssues = issues.map((issue) => (\n     <li key={issue.id}>\n-      <IssueListItem {...issue} showIssueComments={showIssueComments} />\n+      <IssueListItem {...issue} />\n     </li>\n   ))\n\n   return <ul className={styles.issuesList}>{renderedIssues}</ul>\n }\n+\n+export const IssuesList = () => (\n+  <Suspense fallback={<div>Loading...</div>}>\n+    <IssuesListLoaded />\n+  </Suspense>\n+)\n")),(0,r.kt)("p",null,"When react renders ",(0,r.kt)("inlineCode",{parentName:"p"},"IssuesListLoaded"),", it will call ",(0,r.kt)("inlineCode",{parentName:"p"},"useIssues()"),",\nwhich internally will subscribe to the stream, and start fetching the value\nfrom GitHub's API. As that value won't be resolved immediately, the component\nwill be put in suspense until we get a response back from the server."),(0,r.kt)("p",null,"At that point, the component will exit suspense and ",(0,r.kt)("inlineCode",{parentName:"p"},"issues")," will have\nthe value expected."),(0,r.kt)("p",null,"Then, when the user changes to another repo or page, ",(0,r.kt)("inlineCode",{parentName:"p"},"useIssues()")," will put\nthe component in suspense again until the new request has loaded."),(0,r.kt)("h3",{id:"issuedetailspage"},"IssueDetailsPage"),(0,r.kt)("p",null,"Here, by also using error boundaries and suspense, we can break down this\ncomponent into smaller ones. There are ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/re-rxjs/react-rxjs-github-issues-example/commit/d3932f4cf64943e831fc710638669ce3fca75d84#diff-1a799039b78ec6f0b5ab3f324755c673"},"too many changes"),"\nto be able to follow this, but the result would be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'import React, { Suspense } from "react"\nimport ReactMarkdown from "react-markdown"\nimport classnames from "classnames"\n\nimport { insertMentionLinks } from "utils/stringUtils"\nimport { IssueLabels } from "components/IssueLabels"\n\nimport { IssueMeta } from "./IssueMeta"\nimport { IssueComments } from "./IssueComments"\n\nimport styles from "./IssueDetailsPage.module.css"\nimport "./IssueDetailsPage.css"\nimport { ErrorBoundary, FallbackProps } from "react-error-boundary"\nimport { onIssueUnselecteed, useIssue, useSelectedIssueId } from "state"\n\nconst Comments: React.FC = () => {\n  const { comments } = useIssue()\n  return comments === 0 ? (\n    <div className="issue-detail--no-comments">No comments</div>\n  ) : (\n    <Suspense\n      fallback={\n        <div className="issue-detail--comments-loading">Coments loading...</div>\n      }\n    >\n      <IssueComments />\n    </Suspense>\n  )\n}\n\nconst BackButton = () => (\n  <button className="pure-button" onClick={onIssueUnselecteed}>\n    Back to Issues List\n  </button>\n)\n\nconst IssueDetails: React.FC = () => {\n  const issue = useIssue()\n  return (\n    <div className={classnames("issueDetailsPage", styles.issueDetailsPage)}>\n      <h1 className="issue-detail__title">{issue.title}</h1>\n      <BackButton />\n      <IssueMeta issue={issue} />\n      <IssueLabels labels={issue.labels} className={styles.issueLabels} />\n      <hr className={styles.divider} />\n      <div className={styles.summary}>\n        <ReactMarkdown\n          className={"testing"}\n          source={insertMentionLinks(issue.body)}\n        />\n      </div>\n      <hr className={styles.divider} />\n    </div>\n  )\n}\n\nconst Loading: React.FC = ({ children }) => (\n  <div className="issue-detail--loading">\n    <BackButton />\n    {children}\n  </div>\n)\n\nconst IssueError: React.FC<FallbackProps> = ({ error }) => (\n  <Loading>\n    <p>Something went wrong...</p>\n    <p>{error!.message}</p>\n  </Loading>\n)\n\nconst Issue: React.FC<{ id: number }> = ({ id }) => {\n  return (\n    <div>\n      <ErrorBoundary FallbackComponent={IssueError}>\n        <Suspense\n          fallback={\n            <Loading>\n              <p>Loading issue #{id}...</p>\n            </Loading>\n          }\n        >\n          <IssueDetails />\n          <Comments />\n        </Suspense>\n      </ErrorBoundary>\n    </div>\n  )\n}\n\nconst IssueDetailsPage: React.FC = () => {\n  const id = useSelectedIssueId()\n  return id === null ? null : <Issue id={id} />\n}\n\nexport default IssueDetailsPage\n')),(0,r.kt)("h4",{id:"issuecomments"},"IssueComments"),(0,r.kt)("p",null,"And lastly for the comments of the selected issue, we can also just grab the\nhook from where we declared the state and use it. Because of Suspense, we again\ndon't need to handle the loading case."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"}," import ReactMarkdown from 'react-markdown'\n\n import { insertMentionLinks } from 'utils/stringUtils'\n-import { Issue, Comment } from 'api/githubAPI'\n+import { Comment } from 'api/githubAPI'\n import { UserWithAvatar } from 'components/UserWithAvatar'\n\n import styles from './IssueComments.module.css'\n-\n-interface ICLProps {\n-  issue: Issue\n-  comments: Comment[]\n-}\n+import { useIssueComments } from 'state'\n\n interface ICProps {\n   comment: Comment\n@@ -35,20 +31,8 @@ function IssueComment({ comment }: ICProps) {\n   )\n }\n\n-export function IssueComments({ comments = [], issue }: ICLProps) {\n-  // The issue has no comments\n-  if (issue.comments === 0) {\n-    return <div className=\"issue-detail--no-comments\">No comments</div>\n-  }\n-\n-  // The issue has comments, but they're not loaded yet\n-  if (!comments || comments.length === 0) {\n-    return (\n-      <div className=\"issue-detail--comments-loading\">Comments loading...</div>\n-    )\n-  }\n-\n-  // Comments are loaded\n+export const IssueComments: React.FC = () => {\n+  const comments = useIssueComments()\n   return (\n     <ul className={styles.commentsList}>\n       {comments.map((comment) => (\n")),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"The result of this tutorial can be seen in this CodeSandbox:"),(0,r.kt)("iframe",{src:"https://codesandbox.io/embed/github/re-rxjs/react-rxjs-github-issues-example/tree/master?fontsize=14&hidenavigation=1&theme=dark&view=editor&module=%2Fsrc%2Fstate.ts",style:{width:"100%",height:"500px",border:0,borderRadius:"4px",overflow:"hidden"},title:"react-rxjs-github-issues-example",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),(0,r.kt)("p",null,"With this, we've managed to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Showcase an example of an application that deals with service calls."),(0,r.kt)("li",{parentName:"ul"},"Have the application state declared reactively. This implies:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"We can read the state definition top-to-bottom."),(0,r.kt)("li",{parentName:"ul"},"Every piece of the state declares how it behaves."))),(0,r.kt)("li",{parentName:"ul"},"Solved both of the issues that the original example had on synchronizing\nstates."),(0,r.kt)("li",{parentName:"ul"},"Used two of the newest React techniques to declare loading and error states."),(0,r.kt)("li",{parentName:"ul"},"Reduce boilerplate: the net diff shows a negative number of lines.")),(0,r.kt)("h2",{id:"bonus-code-splitting"},"Bonus: Code splitting"),(0,r.kt)("p",null,"As another advantage, it's worth noting that in this example we've decided to\nkeep all the state defined in a single file: The example is small\nenough, and it's easier to explain this way. However, in a real application you can split\nand co-locate the state in each of the relevant parts of your application, and it\nwill play nicely with code-splitting, if you were to use lazy imports. Let's\nquickly try this to see how it plays a big role in load time."),(0,r.kt)("p",null,"For this example, one part of the application that can be split from the main\napp is the page for issue details: It won't be needed until the user\nclicks on one of the issues, so it's a perfect starting point."),(0,r.kt)("p",null,"With React-RxJS we can just move the streams that are only used by that page\ninto a separate file. Let's put it next to where it will be used, the\n",(0,r.kt)("inlineCode",{parentName:"p"},"IssuesDetailsPage")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"IssuesComments")," components:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { EMPTY } from "rxjs"\nimport {\n  startWith,\n  withLatestFrom,\n  filter,\n  switchMapTo,\n  catchError,\n  switchMap,\n} from "rxjs/operators"\nimport { bind, SUSPENSE } from "@react-rxjs/core"\nimport { Issue, getIssue, getComments } from "api/githubAPI"\nimport { issueSelected$, selectedIssueId$, currentRepo$ } from "state"\n\nexport const onIssueUnselecteed = () => {\n  issueSelected$.next(null)\n}\n\nexport const [useIssue, issue$] = bind(\n  selectedIssueId$.pipe(\n    filter((id): id is number => id !== null),\n    withLatestFrom(currentRepo$),\n    switchMap(([id, { org, repo }]) =>\n      getIssue(org, repo, id).pipe(startWith(SUSPENSE)),\n    ),\n  ),\n)\n\nexport const [useIssueComments, issueComments$] = bind(\n  issue$.pipe(\n    filter((issue): issue is Issue => issue !== SUSPENSE),\n    switchMap((issue) =>\n      getComments(issue.comments_url).pipe(startWith(SUSPENSE)),\n    ),\n  ),\n)\n\nselectedIssueId$\n  .pipe(switchMapTo(issueComments$.pipe(catchError(() => EMPTY))))\n  .subscribe()\n')),(0,r.kt)("p",null,"Then we only need to update the imports for those components to use the above file\ninstead:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -6,7 +6,7 @@ import { Comment } from 'api/githubAPI'\n import { UserWithAvatar } from 'components/UserWithAvatar'\n\n import styles from './IssueComments.module.css'\n-import { useIssueComments } from 'state'\n+import { useIssueComments } from './state'\n\n interface ICProps {\n   comment: Comment\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -11,7 +11,8 @@ import { IssueComments } from './IssueComments'\n import styles from './IssueDetailsPage.module.css'\n import './IssueDetailsPage.css'\n import { ErrorBoundary, FallbackProps } from 'react-error-boundary'\n-import { onIssueUnselecteed, useIssue, useSelectedIssueId } from 'state'\n+import { onIssueUnselecteed, useIssue } from './state'\n+import { useSelectedIssueId } from 'state'\n\n const Comments: React.FC = () => {\n   const { comments } = useIssue()\n@@ -87,7 +88,9 @@ const Issue: React.FC<{ id: number }> = ({ id }) => {\n   )\n }\n\n-export const IssueDetailsPage: React.FC = () => {\n+const IssueDetailsPage: React.FC = () => {\n   const id = useSelectedIssueId()\n   return id === null ? null : <Issue id={id} />\n }\n+\n+export default IssueDetailsPage\n")),(0,r.kt)("p",null,"And use a lazy import with Suspense in App:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"-import React from 'react'\n+import React, { lazy, Suspense } from 'react'\n import './App.css'\n import { RepoSearchForm } from 'features/repoSearch/RepoSearchForm'\n import { IssuesListPage } from 'features/issuesList/IssuesListPage'\n-import { IssueDetailsPage } from 'features/issueDetails/IssueDetailsPage'\n import { useSelectedIssueId } from 'state'\n\n+const IssueDetailsPage = lazy(\n+  () => import('features/issueDetails/IssueDetailsPage')\n+)\n+\n const List: React.FC = () =>\n   useSelectedIssueId() === null ? (\n     <>\n@@ -16,7 +19,9 @@ const List: React.FC = () =>\n const App: React.FC = () => (\n   <div className=\"App\">\n     <List />\n-    <IssueDetailsPage />\n+    <Suspense fallback={null}>\n+      <IssueDetailsPage />\n+    </Suspense>\n   </div>\n )\n")),(0,r.kt)("p",null,"Now let's compare the speed between the original version without code splitting\nand the one that we have optimised with React-RxJS. Looking at the\nChrome Network tab with 3G for react-state:"),(0,r.kt)("img",{src:(0,o.Z)("img/react-state-network-size.png"),alt:"A screenshot of Chrome's Network tab for react-state. Shows the main\nwaterfall chunk is a JS file of 76.8kB (240kB uncompressed), taking 3.71s to\nload"}),(0,r.kt)("p",null,"We see that the chunk that prevents the application from starting until it's\ncompletely loaded weighs 76.8kB compressed (240kB uncompressed), and it took\n3.71s to load. And if we take a look at the same tab for React-RxJS with code\nsplitting:"),(0,r.kt)("img",{src:(0,o.Z)("img/react-rxjs-network-size.png"),alt:"A screenshot of Chrome's Network tab for react-state. Shows the main\nwaterfall chunk is a JS file of 58.6kB (193kB uncompressed), taking 3.31s to\nload"}),(0,r.kt)("p",null,"We can see that it weighs less, and so it also takes less time to load: About\n20kB (40kB uncompressed) less and 12% faster. Although we didn't move 40kB of\nminified code into a separate chunk, we reached this value because webpack\nperforms tree-shaking. This means that things like the 2 API calls\nthat are only done from the ",(0,r.kt)("inlineCode",{parentName:"p"},"IssuesDetailsPage")," component, or the RxJS operators\nthat are only being used for the ",(0,r.kt)("inlineCode",{parentName:"p"},"IssuesDetailsPage"),", were also excluded from\nthe main chunk."))}g.isMDXComponent=!0}}]);